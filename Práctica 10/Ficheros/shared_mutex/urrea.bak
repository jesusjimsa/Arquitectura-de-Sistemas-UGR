#include <unistd.h> 
#include <iostream>
#include <sstream>  
#include <mutex>
#include <shared_mutex>
#include <thread>
#include <condition_variable>


const int N = 4;

std::condition_variable_any cond_var;

class ThreadSafeBarrier {
   public:
 
   void esperar() {
      std::unique_lock<std::shared_mutex> lock(mutex_);
      value++;
      if (value < N){
         cond_var.wait(lock);
      }else{
         cond_var.notify_all();
         value=0;
      }
   }


   private:
      mutable std::shared_mutex mutex_;
      unsigned int value = 0;
}barrera;


void hebra()
{	
	std::stringstream ss;
	ss << std::this_thread::get_id();
	std::string antes = ss.str() + ": antes\n", despues = ss.str() + ": despuÃ©s\n";
		
	while(true)
	{
		std::cout << antes;
		barrera.esperar();
		std::cout << despues;
	}
}


int main() {
   ThreadSafeBarrier barrera;
   
   alarm(1);
   std::thread t[N];
   for (auto& i: t) i = std::thread(hebra);
   for (auto& i: t) i.join();



}
